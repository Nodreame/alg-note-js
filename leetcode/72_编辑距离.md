# [编辑距离](https://leetcode-cn.com/problems/edit-distance/)

- 难度：Hard
- 标签：

## 刷题思路

- [x] 自顶向下(递归)
- [x] 自底向上(dp)

### 方法 1 自顶向下(递归)

- 复杂度：
    - 时间 O(mn)
    - 空间 O(mn)

``` js
var minDistance = function(word1, word2) {
    const dp = Array.from({ length: word1.length }, () => {
        return Array.from({ length: word2.length }, () => Infinity)
    })
    return recursion(word1, word2, word1.length-1, word2.length-1, dp)
};

function recursion (word1, word2, i, j, dp) {
    if (i<0) return j+1
    if (j<0) return i+1
    
    if (dp[i][j] != Infinity) return dp[i][j]
    
    if (word1[i] === word2[j]) {
        dp[i][j] = recursion(word1, word2, i-1, j-1, dp)
    } else {
        dp[i][j] = 1 + Math.min(
            recursion(word1, word2, i-1, j, dp),
            recursion(word1, word2, i-1, j-1, dp),
            recursion(word1, word2, i, j-1, dp),
        )
    }
    return dp[i][j]
}
```

### 方法 2 自底向上(dp)

- 复杂度：
    - 时间 O(mn)
    - 空间 O(mn)

``` js
var minDistance = function(word1, word2) {
    const [len1, len2] = [word1.length, word2.length]
    const dp = Array.from({ length: len1+1 }, () => {
        return Array.from({ length: len2+1 }, () => 0)
    })
    // base case
    for (let i=1; i<=len1; i++) dp[i][0] = i
    for (let i=1; i<=len2; i++) dp[0][i] = i
    
    for (let i=1; i<=len1; i++) {
        for (let j=1; j<=len2; j++) {
            if (word1[i-1] === word2[j-1]) {
                dp[i][j] = dp[i-1][j-1]
            } else {
                dp[i][j] = 1 + Math.min(
                    dp[i-1][j],
                    dp[i-1][j-1],
                    dp[i][j-1],
                )
            }
        }
    }
    return dp[len1][len2]
};
```

**[JS刷题记录 Leetcode-js](https://github.com/Nodreame/leetcode-js)** 每周都会更新刷题心得或者题解, 你的点赞或 star 都将助力我产出更好内容~
